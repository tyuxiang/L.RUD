module mojo_top (
    input clk,              // 50MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input cclk,             // configuration clock, AVR ready when high
    output spi_miso,        // AVR SPI MISO
    input spi_ss,           // AVR SPI Slave Select
    input spi_mosi,         // AVR SPI MOSI
    input spi_sck,          // AVR SPI Clock
    output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel)
    input avr_tx,           // AVR TX (FPGA RX)
    output avr_rx,          // AVR RX (FPGA TX)
    input avr_rx_busy,       // AVR RX buffer full
    input dip
  ) {
  
  sig rst;                                    // reset signal
  alu alu;                                    // alu (input: 1st number, 2nd number, alufn) (output:answer based on operation)
  led_module led_module;                      // displays on the led using the registers (input: LED registers) (output: LED output)
  check_player_module check_player_module;    // check whether button is from correct player
  check_step_module check_step_module;        // check whether step is correct
  answer_key_module answer_key_module;        // reads the answer key and outputs LRUD
  button_module button_module;                // reads which button is from which player and its LRUD
  convert_to_alu convert_to_alu;              // reads LRUD and outputs the alufn and 16bit input into alu
  move move;                                  // changes value of led register to 1 and all other led register to 0 (input: address of register)
  
  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    edge_detector edge_detector (#RISE(1), #FALL(0)); //initialize edge_detector to detect edges
    .rst(rst) {
      dff current_map;
      dff current_step[2];
      dff map_0[12];
      dff map_1[12];
      dff reg_led[16];
      dff answer_player;
      dff current_pos[4];
      dff seed [32];                      // seed for each run
      fsm state = {START, SET_MAP, SET_START, SET_STEP, IDLE, CHECK_PLAYER, CHECK_STEP, WIN, ERROR};
      counter ctr (#SIZE(1), #DIV(25));   // Initialize counter to count every 2^25(~33.5 million) clock cycle, on MOJO is 50 million clock cycle per reset_cond
      
    }
    pn_gen rng; 
  }
  
  always {
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
    
    led = 8h00;             // turn LEDs off
    spi_miso = bz;          // not using SPI
    spi_channel = bzzzz;    // not using flags
    avr_rx = bz;            // not using serial port
    edge_detector.in = bz; // Have 0 output from edge_detector
    
    rng.seed = seed.q;              // use seed.q as the seed
    rng.next = 0;                   // don't generate new numbers
    rng.rst = rst;
    
    if(dip){
      edge_detector.in = ctr.value;      // Input value of counter into edge detector
    }
      
    case (state.q) {
      state.START:
        if(dip & edge_detector.out){
          state.d = state.SET_MAP;
        }
        
      state.SET_MAP:
        led = 1;
        
      state.SET_START:
        led = 1;
        
      state.SET_STEP:
        led = 1;
      
      state.IDLE:
        led = 1;
        
      state.CHECK_PLAYER:
        led = 1;
        
      state.CHECK_STEP:
        led = 1;
        
      state.WIN:
        led = 1;
        
      state.ERROR:
        led = 1;
    }
  }
}