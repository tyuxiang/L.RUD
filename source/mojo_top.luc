module mojo_top (
    input clk,              // 50MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input cclk,             // configuration clock, AVR ready when high
    output spi_miso,        // AVR SPI MISO
    input spi_ss,           // AVR SPI Slave Select
    input spi_mosi,         // AVR SPI MOSI
    input spi_sck,          // AVR SPI Clock
    output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel)
    input avr_tx,           // AVR TX (FPGA RX)
    output avr_rx,          // AVR RX (FPGA TX)
    input avr_rx_busy,      // AVR RX buffer full
    output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    output io_sel [4],      // Digit select on IO Shield
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [3][8],    // DIP switches on IO Shield
    output led0,            // Output led 0
    output led1,            // Output led 1
    output led2,            // Output led 2
    output led3,            // Output led 3
    output led4,            // Output led 4
    output led5,            // Output led 5
    output led6,            // Output led 6
    output led7,            // Output led 7
    output led8,            // Output led 8
    output led9,            // Output led 9
    output led10,           // Output led 10
    output led11,           // Output led 11
    output led12,           // Output led 12
    output led13,           // Output led 13
    output led14,           // Output led 14
    output led15            // Output led 15
  ) {
  
  sig rst;                                    // reset signal
  new_alu alu;                                // alu (input: 1st number, 2nd number, alufn) (output:answer based on operation)
  led_module led_module;                      // displays on the led using the registers (input: LED registers) (output: LED output)
  check_player_module check_player_module;    // check whether button is from correct player
  check_step_module check_step_module;        // check whether step is correct
  answer_key_module answer_key_module;        // reads the answer key and outputs LRUD
  button_module button_module;                // reads which button is from which player and its LRUD
  convert_to_alu convert_to_alu;              // reads LRUD and outputs the alufn and 16bit input into alu
  move move;                                  // changes value of led register to 1 and all other led register to 0 (input: address of register)
  
  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    edge_detector edge_detector (#RISE(1), #FALL(0)); //initialize edge_detector to detect edges
    .rst(rst) {
      dff current_map[12];
      dff current_step[2];
      dff map_number;
      dff step_number[2];
      dff map_0[12];
      dff map_1[12];
      dff reg_led[16];
      dff answer_player;
      dff current_pos[4];
      dff seed [32];                      // seed for each run
      fsm state = {START, SET_MAP, SET_START, SET_STEP, IDLE, CHECK_PLAYER, CHECK_STEP, WIN, ERROR};
      counter ctr (#SIZE(1), #DIV(25));   // Initialize counter to count every 2^25(~33.5 million) clock cycle, on MOJO is 50 million clock cycle per reset_cond
      
    }
    pn_gen rng; 
  }
  
  always {
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
    
    led = 8h00;             // turn LEDs off
    spi_miso = bz;          // not using SPI
    spi_channel = bzzzz;    // not using flags
    avr_rx = bz;            // not using serial port
    edge_detector.in = bz; // Have 0 output from edge_detector
    
    io_led = 3x{{8h00}};    // turn LEDs off
    io_seg = 8hff;          // turn segments off
    io_sel = 4hf;           // select no digits
    
    rng.seed = seed.q;      // use seed.q as the seed
    rng.next = 0;           // don't generate new numbers
    rng.rst = rst;
    
    alu.firstNumber = 16x{0};  // input zero first
    alu.secondNumber = 16x{0}; // input zero first
    alu.alufn = 6x{0};         // input zero first
    
    check_player_module.answer_player = 0;  //input zero first
    check_player_module.player = 0;         //input zero first
    
    check_step_module.lrud_answer = 0;      //input zero first
    check_step_module.lrud_player = 0;      //input zero first
    
    answer_key_module.current_map = 16x{0}; //input zero first
    answer_key_module.current_step = 4x{0}; //input zero first
    
    button_module.button = 3x{0};           //input zero first
    
    move.current_pos = 4x{0};               //input zero first
    
    convert_to_alu.lrud = b00;              //input zero first
    
    //00 is left, 01 is right, 10 is up, 11 is down
    map_0.d = b000001010111; //start at led0 then [right,right,right,down]
    map_1.d = b111100000010; //start at led15 then [left,left,left,up]
    answer_player.d = 0;     //initialize starting player to answer to be player 1
    reg_led.d = 16x{0};      //initialize all led reg to be 0
    step_number.d = b00;     //initialize step number to be 0
    seed.d = 32x{0};         //initialize seed number to be 0
    
    led_module.reg_led = reg_led.q;         //connect reg led to led module
    
    //connect led module output to actual output
    led0 = led_module.led0;
    led1 = led_module.led1;
    led2 = led_module.led2;
    led3 = led_module.led3;
    led4 = led_module.led4;
    led5 = led_module.led5;
    led6 = led_module.led6;
    led7 = led_module.led7;
    led8 = led_module.led8;
    led9 = led_module.led9;
    led10 = led_module.led10;
    led11 = led_module.led11;
    led12 = led_module.led12;
    led13 = led_module.led13;
    led14 = led_module.led14;
    led15 = led_module.led15;
    
    //io_led[1][7:0] = num.q[15:8];
    //io_led[0][7:0] = num.q[7:0];
    io_led[0][0] = map_number.q;
    
    if(io_dip[2][7]){
      edge_detector.in = ctr.value;      // Input value of counter into edge detector
    }
      
    case (state.q) {
      state.START:
        io_led[2][7] = 1;
        if(io_dip[2][7] & edge_detector.out){
          state.d = state.SET_MAP;
        }
        
      state.SET_MAP:
        io_led[2][6] = 1;
        rng.next = 1;
        map_number.d = rng.num[0];
        if(edge_detector.out){
          state.d = state.SET_START;
        }

      state.SET_START:
        io_led[2][5] = 1;
        if(map_number.q == 0){
          current_pos.d = map_0.q[11:8];
        }
        else if(map_number.q == 1){
          current_pos.d = map_1.q[11:8];
        }
        if(edge_detector.out){
          state.d = state.START;
        }
        
      state.SET_STEP:
        led = 1;
      
      state.IDLE:
        led = 1;
        
      state.CHECK_PLAYER:
        led = 1;
        
      state.CHECK_STEP:
        led = 1;
        
      state.WIN:
        led = 1;
        
      state.ERROR:
        led = 1;
    }
  }
}