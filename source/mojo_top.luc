module mojo_top (
    input clk,              // 50MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input cclk,             // configuration clock, AVR ready when high
    output spi_miso,        // AVR SPI MISO
    input spi_ss,           // AVR SPI Slave Select
    input spi_mosi,         // AVR SPI MOSI
    input spi_sck,          // AVR SPI Clock
    output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel)
    input avr_tx,           // AVR TX (FPGA RX)
    output avr_rx,          // AVR RX (FPGA TX)
    input avr_rx_busy,      // AVR RX buffer full
    output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    output io_sel [4],      // Digit select on IO Shield
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [3][8],    // DIP switches on IO Shield
    output led0,            // Output led 0
    output led1,            // Output led 1
    output led2,            // Output led 2
    output led3,            // Output led 3
    output led4,            // Output led 4
    output led5,            // Output led 5
    output led6,            // Output led 6
    output led7,            // Output led 7
    output led8,            // Output led 8
    output led9,            // Output led 9
    output led10,           // Output led 10
    output led11,           // Output led 11
    output led12,           // Output led 12
    output led13,           // Output led 13
    output led14,           // Output led 14
    output led15,           // Output led 15
    input p1_left,
    input p1_right,
    input p1_up,
    input p1_down,
    input p2_left,
    input p2_right,
    input p2_up,
    input p2_down
  ) {
  
  sig rst;                                    // reset signal
  new_alu alu;                                // alu (input: 1st number, 2nd number, alufn) (output:answer based on operation)
  led_module led_module;                      // displays on the led using the registers (input: LED registers) (output: LED output)
  check_player_module check_player_module;    // check whether button is from correct player
  check_step_module check_step_module;        // check whether step is correct
  answer_key_module answer_key_module;        // reads the answer key and outputs LRUD
  button_module button_module;                // reads which button is from which player and its LRUD
  convert_to_alu convert_to_alu;              // reads LRUD and outputs the alufn and 16bit input into alu
  move move;                                  // changes value of led register to 1 and all other led register to 0 (input: address of register)
  
  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    edge_detector edge_detector (#RISE(1), #FALL(0)); //initialize edge_detector to detect edges
    .rst(rst) {
      dff current_map[12];
      dff current_step[2];
      dff map_number;
      dff step_number[3];
      dff map_0[12];
      dff map_1[12];
      dff reg_led[16];
      dff answer_player;
      dff current_pos[4];
      dff seed [32];                      // seed for each run
      dff alu_answer[16];
      fsm state = {START, SET_MAP, SET_START, SET_STEP, COMPUTE_STEP, OUTPUT_STEP, DISPLAY_STEP, IDLE, CHECK_PLAYER, CHECK_STEP, WIN, ERROR};
      counter ctr (#SIZE(1), #DIV(24));   // Initialize counter to count every 2^25(~33.5 million) clock cycle, on MOJO is 50 million clock cycle per reset_cond
      
    }
    pn_gen rng;
  }
  
  always {
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
    
    led = 8h00;             // turn LEDs off
    spi_miso = bz;          // not using SPI
    spi_channel = bzzzz;    // not using flags
    avr_rx = bz;            // not using serial port
    edge_detector.in = bz; // Have 0 output from edge_detector
    
    io_led = 3x{{8h00}};    // turn LEDs off
    io_seg = 8hff;          // turn segments off
    io_sel = 4hf;           // select no digits
    
    rng.seed = seed.q;      // use seed.q as the seed
    rng.next = 0;           // don't generate new numbers
    rng.rst = rst;
    
    alu.firstNumber = 16x{0};  // input zero first
    alu.secondNumber = 16x{0}; // input zero first
    alu.alufn = 6x{0};         // input zero first
    
    check_player_module.answer_player = 0;  //input zero first
    check_player_module.player = 0;         //input zero first
    
    check_step_module.lrud_answer = 0;      //input zero first
    check_step_module.lrud_player = 0;      //input zero first
    
    answer_key_module.current_map = 16x{0}; //input zero first
    answer_key_module.current_step = 4x{0}; //input zero first
    
    move.current_pos = 4x{0};               //input zero first
    
    convert_to_alu.lrud = b00;              //input zero first
    
    led_module.reg_led = reg_led.q;         //connect reg led to led module
    
    button_module.button0 = p1_left;
    button_module.button1 = p1_right;
    button_module.button2 = p1_up;
    button_module.button3 = p1_down;
    button_module.button4 = p2_left;
    button_module.button5 = p2_right;
    button_module.button6 = p2_up;
    button_module.button7 = p2_down;    
    
    //connect led module output to actual output
    led0 = led_module.led0;
    led1 = led_module.led1;
    led2 = led_module.led2;
    led3 = led_module.led3;
    led4 = led_module.led4;
    led5 = led_module.led5;
    led6 = led_module.led6;
    led7 = led_module.led7;
    led8 = led_module.led8;
    led9 = led_module.led9;
    led10 = led_module.led10;
    led11 = led_module.led11;
    led12 = led_module.led12;
    led13 = led_module.led13;
    led14 = led_module.led14;
    led15 = led_module.led15;
    
    //io_led[1][7:0] = num.q[15:8];
    //io_led[0][7:0] = num.q[7:0];
    io_led[0][0] = map_number.q;
    io_led[0][5:1] = current_pos.q;
    io_led[0][7:6] = current_step.q;
    io_led[1][2:0] = step_number.q;
    //io_led[1] = reg_led.q[15:8];
    //io_led[0] = reg_led.q[7:0];
    io_led[1] = alu_answer.q[15:8];
    io_led[0] = alu_answer.q[7:0];
    
    if(io_dip[2][7]){
      edge_detector.in = ctr.value;      // Input value of counter into edge detector
    }
      
    case (state.q) {
      state.START:
        //00 is left, 01 is right, 10 is up, 11 is down
        map_0.d = b000001010111; //start at led0 then [right,right,right,down]
        map_1.d = b111100000010; //start at led15 then [left,left,left,up]
        answer_player.d = 0;     //initialize starting player to answer to be player 1
        reg_led.d = b00000000000000000;      //initialize all led reg to be 0
        step_number.d = b000;     //initialize step number to be 0
        io_led[2][7] = 1;
        if(io_dip[2][7] & edge_detector.out){
          state.d = state.SET_MAP;
        }
        
      state.SET_MAP:
        io_led[2][6] = 1;
        rng.next = 1;
        map_number.d = rng.num[0];
        if(rng.num[0] == 0){
          current_map.d = map_0.q;
        }
        if(rng.num[0] == 1){
          current_map.d = map_1.q;
        }
        if(edge_detector.out){
          state.d = state.SET_START;
        }

      state.SET_START:
        io_led[2][5] = 1;
        
        //update current step with first 4 bits of map
        current_pos.d = current_map.q[11:8];
        
        //convert current step to reg_led
        move.current_pos = current_pos.q;
        
        //update reg led with move output
        reg_led.d = move.reg_led;
        
        if(edge_detector.out){
          state.d = state.SET_STEP;
        }
        
      state.SET_STEP:
        io_led[2][4] = 1;
        
        //set the step based on step_number
        if(step_number.q == 0){
          current_step.d = current_map.q[7:6];
          if(edge_detector.out & current_step.q == current_map.q[7:6]){
          step_number.d = step_number.q + 1;
          state.d = state.COMPUTE_STEP;
          }
        }
        else if(step_number.q == 1){
          current_step.d = current_map.q[5:4];
          if(edge_detector.out & current_step.q == current_map.q[5:4]){
          step_number.d = step_number.q + 1;
          state.d = state.COMPUTE_STEP;
          }
        }
        else if(step_number.q == 2){
          current_step.d = current_map.q[3:2];
          if(edge_detector.out & current_step.q == current_map.q[3:2]){
          step_number.d = step_number.q + 1;
          state.d = state.COMPUTE_STEP;
          }
        }
        else if(step_number.q == 3){
          current_step.d = current_map.q[1:0];
          if(edge_detector.out & current_step.q == current_map.q[1:0]){
          step_number.d = step_number.q + 1;
          state.d = state.COMPUTE_STEP;
          }
        }
      
      state.COMPUTE_STEP:
        io_led[2][3] = 1;
        //input current step into convert_to_alu
        convert_to_alu.lrud = current_step.q;
        //step_number.d = step_number.q + 1;
        alu.firstNumber = current_pos.q;
        alu.secondNumber = convert_to_alu.value;
        alu.alufn = convert_to_alu.alufn;
        //update the new current pos
        current_pos.d = alu.answer[3:0];
        alu_answer.d = alu.answer;
        state.d = state.OUTPUT_STEP;
      
      state.OUTPUT_STEP:
        io_led[2][2] = 1;
        //convert current step to reg_led
        move.current_pos = current_pos.q;
        //update reg led with move output
        reg_led.d = move.reg_led;
        if(edge_detector.out & step_number.q == 4){
          // Re-initialize the step number and the current pos
          step_number.d = 0;
          current_pos.d = current_map.q[11:8];
          state.d = state.IDLE;
        }
        else if(edge_detector.out){
          state.d = state.SET_STEP;
        }
      
      state.IDLE:
        io_led[2][1] = 1;
        if(step_number.q == 0){
          current_step.d = current_map.q[7:6];
        }
        else if(step_number.q == 1){
          current_step.d = current_map.q[5:4];
        }
        else if(step_number.q == 2){
          current_step.d = current_map.q[3:2];
        }
        else if(step_number.q == 3){
          current_step.d = current_map.q[1:0];
        }
        if(p1_left == 1 | p1_right == 1 | p1_up == 1 | p1_down == 1 | p2_left == 1 | p2_right == 1 | p2_up == 1 | p2_down == 1){
          state.d = state.CHECK_PLAYER;
        }
        
      state.CHECK_PLAYER:
        io_led[2][0] = 1;
        if(button_module.player == answer_player.q){
          answer_player.d = 1 - answer_player.q;
          state.d = state.CHECK_STEP;
        }
        else{
          state.d = state.ERROR;
        }
        
      state.CHECK_STEP:
        if(button_module.lrud == current_step.q){
          if(current_step.q == 3){
            state.d = state.WIN;
          }
          else{
            step_number.d = step_number.q + 1;
            state.d = state.IDLE;
          }
        }
        else{
          state.d = state.ERROR;
        }
        
      state.WIN:
        //on alternate led
        reg_led.d = b1010101010101010;
        
      state.ERROR:
        //on all led
        reg_led.d = b1111111111111111;
    }
  }
}